Plan

Format of read data

{
    "station" : [  #numpy array
        (date_and_time, {
            "no" : no_value,
            "pm10" : pm10_value,
            "pm25" : pm25_value
        })
    ]
}

Reporting Module

daily_average(data, monitoring_station : str, pollutant : str) -> list (365 values)

Pseudocode:
Iterate over the list associated with the station.
Mean_daily_values = []

for i in 365:
    normal_values = []
    for j in 24:
        if value is a float  #use isinstance() to avoid an error for 'No Data'
            Add values to a list.  #index = i * 24 + j
    Call meanvalue(list)
    Add the return value to a list of mean_daily_values
return mean_daily_values

daily_median(data, monitoring_station : str, pollutant : str) -> list  (using an insertion sort)

Pseudocode:
Iterate over the list associated with the station.
median_daily_values = []
for i in 365:
    sorted_normal_values = []
    for j in 24:
        if value is a float:
            if j == 0:
                add value to list
            else:
                for index in range(len(sorted_normal_values))):
                    if value <= sorted_normal_values[index]:
                        sorted_normal_values.insert(index, value)
                        break
    median_daily_values.append(median_value(sorted_normal_values))
return median_daily_values

Insertion_sort()
for i in range(values):
    bool found_location = false
    int index_to_compare = i + 1
    while (not found_location and index_to_compare != len(values):
        if values[i] > values[index_to_compare]:
            temp = values[index_to_compare]
            values[index_to_compare] = values[i]
            values[i] = temp
            index_to_compare += 1
        else:
            found_location = true
    return values;


hourly_average(data, monitoring_station : str, pollutant : str) -> list

monthly_average(data, monitoring_station : str, pollutant : str) -> list


monthly_average_data = array of length 12

index = 0
for i in range 0 to 12:
    normal_monthly_data = list (as month length is not a fixed size)
    same_month = true
    current_month = empty string
    while same_month:
        current_month = data[::::]
        if len(data) != index + 1 && data[index + 1] != current_month:
            same_month = false
        normal_monthly_data.append(value)
        index++
    monthly_average_data.append(meanvalue(normal_monthly_data))





peak_hour_date(data, monitoring_station : str, pollutant : str) -> string (hour date)

**For a givendate (e.g., 2021-01-01) returns the hour of the day with the highest pollution level and its corresponding value (e.g., (12:00, 14.8))

found_date = false
starting_index = 0    
while not found_date:
    if data[index][::] != date or len(data) -1 == starting_index:
        starting_index += 1
    else:
        found_date = true
if starting_index >= len(data)-1:
    raise exception
time_and_max_value = "", -1 
for i in range(0,24):
    value = data[starting_index + i]
    if value < time_and_max_value[1]:
        time_and_max_value[0] = time
        time_and_max_value[1] = value
return time_and_max_value
        
    


count_missing_data(data, monitoring_station : str, pollutant : str) -> int

fill_missing_data(data, monitoring_station : str, pollutant : str) -> copy of data


=============  MONITORING MODULE =======================
4 functions that provide information about air pollution from the London air API.

Validation:
Validate that the site_code is valid.
Validate that the pollution type is monitored at that monitoring site.
Validate start and end dates - that they were monitoring the pollutant at that site at that specific period of time.
User inputs.



Functions:
** get_monitoring_sites_and_pollutants_monitored():
return in form:
{
    site_code : [{
        'pollutant1_code' : {
            'start_date' : date,
            'end_date' : date
        }, {
            ...
        }
    }]
}
Pseudocode: data = dict response from api
my_data = {}
for monitoring_site in data["Sites"]["Site"]:  #List of dictionaries
    my_data["@Site_Code"] = [
        {monitoring_site_pollutants[@SpeciesCode] : {
            start : monitoring_site_pollutants[]
            }
        } for monitoring_site_pollutants in [monitoring_site["Species"]] ]  #monitoring_site["Species"] may be a dict or a list of dicts so need to convert to a list
    

** Plot multiple pollutants on the same graph (for the same monitoring site) for a given time period (if not measured during that period then just have a discontuinity)

** 


